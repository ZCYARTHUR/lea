<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>LEA åŠ¨ç”» Â· DOM å¤šæ¨¡å¼ + GPU ç²’å­å­—å½¢åœº</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%230b0c10'/%3E%3Ctext x='50' y='60' text-anchor='middle' font-size='52' fill='%23fff' font-family='Arial'%3Eâ˜…%3C/text%3E%3C/svg%3E">
<style>
  :root{ --btn-bg:#000; --btn-fg:#fff; --menu-bg:rgba(0,0,0,.85); --menu-fg:#fff; }
  html,body{height:100%;margin:0;padding:0;overflow:hidden;background:#fff;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
  #stage{position:relative;width:100vw;height:100vh;overflow:hidden}

  /* GPU å®¹å™¨ */
  #gpuRoot{position:fixed; inset:0; display:none; background:#0b0c10}
  #gpuCanvas{position:absolute; inset:0; width:100%; height:100%; display:block}
  #gpuDiag{position:fixed; left:10px; bottom:10px; color:#94a3b8; font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Helvetica,Arial; z-index:9; opacity:.9; pointer-events:none}

  /* å¡ç‰‡ï¼ˆå¼¹çª—ï¼‰ */
  .tile{
    position:absolute; display:flex; align-items:center; justify-content:center;
    border-radius:10px; padding:0 6px; box-sizing:border-box;
    font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Segoe UI",Arial,Helvetica,sans-serif;
    line-height:1.1; text-align:center; word-break:break-word;
    box-shadow:0 2px 8px rgba(0,0,0,.12);
    will-change:transform,opacity; cursor:pointer;
  }

  /* å·¥å…·æ å’Œèœå• */
  .toolbar{position:fixed; right:12px; top:12px; z-index:9999; display:flex; gap:8px}
  .btn{
    padding:8px 12px; border-radius:999px; border:0; background:var(--btn-bg); color:var(--btn-fg);
    font-size:14px; opacity:.85; cursor:pointer
  }
  .btn:hover{opacity:1}
  .menu{
    position:absolute; right:0; top:44px; min-width:200px;
    background:var(--menu-bg); color:var(--menu-fg); border-radius:12px; overflow:hidden;
    display:none; z-index:10000; box-shadow:0 10px 30px rgba(0,0,0,.25); backdrop-filter: blur(8px);
  }
  .menu.open{display:block}
  .menu button{display:block;width:100%;text-align:left;padding:10px 14px;background:transparent;color:#fff;border:0;cursor:pointer;font-size:14px}
  .menu button:hover{background:rgba(255,255,255,.08)}

  /* ç²’å­ï¼ˆå¿ƒ/çº¸å±‘/é›ª/æ°”çƒï¼‰ */
  .particle{position:absolute; pointer-events:none; will-change:transform,opacity}
  .heart{font-size:16px; filter:drop-shadow(0 1px 2px rgba(0,0,0,.2))}
  .confetti{width:8px; height:12px; transform-origin:50% 50%; border-radius:2px}
  .snow{width:8px; height:8px; border-radius:50%; background:rgba(255,255,255,.95); box-shadow:0 0 10px rgba(255,255,255,.8)}
  .balloon{width:18px; height:24px; border-radius:50% 50% 50% 50% / 60% 60% 40% 40%; box-shadow:0 3px 10px rgba(0,0,0,.15)}

  .secret{ outline:2px dashed rgba(0,0,0,.2); box-shadow:0 6px 16px rgba(0,0,0,.18)!important; }

  .unlock-mask{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:10001; background:rgba(255,255,255,0); -webkit-tap-highlight-color: transparent;}
  .unlock-mask.show{ display:flex; }
  .unlock-card{ background:rgba(0,0,0,.65); color:#fff; padding:10px 14px; border-radius:12px; font-size:14px; box-shadow:0 6px 24px rgba(0,0,0,.25); }

  @media (prefers-reduced-motion: reduce){ .tile,.particle{animation:none!important} }
</style>
</head>
<body>
  <!-- DOM åŠ¨ç”»èˆå° -->
  <div id="stage"></div>

  <!-- GPU ç²’å­å­—å½¢åœº -->
  <div id="gpuRoot"><canvas id="gpuCanvas"></canvas></div>
  <div id="gpuDiag" aria-hidden="true"></div>

  <!-- éŸ³ä¹ -->
  <audio id="bgm" preload="auto" loop autoplay playsinline>
    <source src="lea.mp3" type="audio/mpeg">
  </audio>

  <!-- å·¥å…·æ  -->
  <div class="toolbar">
    <button id="btnMode" class="btn" aria-haspopup="true" aria-expanded="false">æ¨¡å¼ï¼šLEA</button>
    <button id="btnClear" class="btn">æ¸…å±</button>
    <button id="btnGPUText" class="btn" style="display:none">å­—ï¼šLEA</button>

    <button id="btnMusic" class="btn">éŸ³ä¹ï¼šæ’­æ”¾</button>
    <div id="menuMusic" class="menu" aria-label="éŸ³ä¹èœå•">
      <div style="padding:10px 14px">
        <div style="display:flex;align-items:center;gap:8px">
          <span style="color:#bbb;font-size:12px;width:36px">éŸ³é‡</span>
          <input id="musicVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px">
          <button id="btnMute" class="btn" style="padding:6px 10px;font-size:12px;background:#333">é™éŸ³</button>
        </div>
      </div>
    </div>

    <div id="menuMode" class="menu" aria-label="æ¨¡å¼èœå•" role="menu">
      <button data-mode="LEA">LEA å­—å½¢ + å¼¹çª—</button>
      <button data-mode="HEART_RAIN">å¿ƒå½¢é›¨</button>
      <button data-mode="FIREWORKS">çƒŸèŠ±</button>
      <button data-mode="SNOW">é›ªèŠ±</button>
      <button data-mode="BALLOONS">æ°”çƒä¸Šæµ®</button>
      <button data-mode="CONFETTI">Confetti</button>
      <div style="border-top:1px solid rgba(255,255,255,.12);"></div>
      <button data-mode="GPU">GPU å­—å½¢ç²’å­ï¼ˆé«˜æ€§èƒ½ï¼‰</button>
    </div>
  </div>

  <div id="unlockMask" class="unlock-mask"><div class="unlock-card">ğŸ”Š è½»è§¦å±å¹•å¼€å¯éŸ³ä¹</div></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

(() => {
/* ============ DOM ç‰ˆæœ¬ä¿ç•™ï¼ˆåŸæœ‰åŠŸèƒ½ï¼‰ ============ */
const WORD = "LEA";
const START_MS = 200, END_MS = 20, JITTER_PX = 3, COVER_RATIO = 0.8, CELL_GAP = 4, LEA_FADE_MS = 260;
const WIN_W = 240, WIN_H = 64, JITTER_RATIO = 0.4;

const TIPS_SETS = [
  ['LeaæŒ‰æ—¶åƒé¥­~','leaä¿æŒå¾®ç¬‘å‘€','Leaæ—©ç‚¹å›å®¶~','è®°å¾—åƒæ°´æœ','Leaä½ å·²ç»å¾ˆæ£’äº†å‘€~','å¥½å¥½çˆ±è‡ªå·±','Leaç§‹æ‹›ä¸Šå²¸','æ¢¦æƒ³æˆçœŸ','Leaæ˜¥æ‹›ä¸Šå²¸','é¡ºé¡ºåˆ©åˆ©','LeaæŒ‰æ—¶åƒé¥­','æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±','åˆ«ç†¬å¤œ','Leaä»Šå¤©è¿‡å¾—å¼€å¿ƒå˜›','æ‚‰å°¼å¤©å†·äº†ï¼Œå¤šç©¿è¡£æœ'],
  ['ä»Šå¤©ä¹Ÿè¦å¼€å¿ƒ','å–æ°´ï¼','æ·±å‘¼å¸ä¸‰æ¬¡','æ—©ç‚¹ç¡åˆ«ç†¬å¤œ','ä½ å€¼å¾—æœ€å¥½çš„ä¸€åˆ‡','å°ç¡®å¹¸æ­£åœ¨è·¯ä¸Š','å»æ•£ä¸ªæ­¥å§','åšä¸€ä»¶å°å°ä½†æ­£ç¡®çš„äº‹'],
  ['ç¥ä½ ä¸€è·¯é¡ºé£','ä¸‡äº‹é¡ºåˆ©','æ‰€æ„¿çš†æˆçœŸ','å¹³å®‰å–œä¹','å¥½äº‹å‘ç”Ÿåœ¨ä»Šå¤©','å¥½è¿æ’é˜Ÿæ¥']
];
const PALETTES = [
  ['#ffd3e0','#bde0fe','#c7f9cc','#e9e5ff','#fff6b3','#ffcfb3'],
  ['#f9e2af','#a6e3a1','#f5c2e7','#cba6f7','#89dceb','#fab387'],
  ['#ffedd5','#d1fae5','#e0e7ff','#fef9c3','#fee2e2','#f1f5f9']
];
let TIPS = TIPS_SETS[0], BG_COLORS = PALETTES[0];

const FONT_5x7 = {
  'L': ["1....","1....","1....","1....","1....","1....","11111"],
  'E': ["11111","1....","1....","1111.","1....","1....","11111"],
  'A': [".111.","1...1","1...1","11111","1...1","1...1","1...1"],
  ' ': [".....",".....",".....",".....",".....",".....","....."],
};

const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = arr => arr[Math.floor(Math.random()*arr.length)];

const timers = new Set(), intervals = new Set();
function later(fn,ms){ const id=setTimeout(()=>{timers.delete(id); fn();},ms); timers.add(id); return id; }
function every(fn,ms){ const id=setInterval(fn,ms); intervals.add(id); return id; }
function clearAllTimers(){ for(const t of timers) clearTimeout(t); timers.clear(); for(const i of intervals) clearInterval(i); intervals.clear(); }

function makeTile(stage, spec, text="", tag=null){
  const div = document.createElement('div');
  div.className = 'tile'; div.dataset.tag = tag || '';
  Object.assign(div.style, {left:spec.x+'px', top:spec.y+'px', width:spec.w+'px', height:spec.h+'px', background:choice(BG_COLORS), fontSize:Math.max(10, Math.floor(Math.min(spec.w,spec.h)/2.9)) + 'px'});
  div.textContent = text;
  const clickBurst = () => {
    const rect = div.getBoundingClientRect();
    const cx = rect.left + rect.width/2 + window.scrollX;
    const cy = rect.top  + rect.height/2 + window.scrollY;
    Math.random() < 0.5 ? burstHearts(cx, cy) : burstConfetti(cx, cy);
  };
  let pressTimer=null, pressed=false;
  const onDown = ()=>{ pressed=true; pressTimer=setTimeout(()=>{ if(pressed){ div.classList.add('secret'); div.textContent = choice(['ğŸ ä½ è¶…æ£’','ğŸ’– å°å°å¥½è¿å·²ç­¾æ”¶','ğŸŒŸ ä»Šæ—¥é™å®šå¥½å¿ƒæƒ…','ğŸ¯ ä¸€åˆ‡é¡ºåˆ©']); div.animate([{transform:'scale(1)'},{transform:'scale(1.06)'}], {duration:220, fill:'forwards', easing:'ease-out'}); } },600); };
  const onUp = ()=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } if(pressed && !div.classList.contains('secret')) clickBurst(); pressed=false; };
  div.addEventListener('pointerdown', onDown); window.addEventListener('pointerup', onUp);
  stage.appendChild(div);
  div.animate([{opacity:0,transform:'scale(0.92)'},{opacity:1,transform:'scale(1)'}], {duration:180, easing:'ease-out'});
  return div;
}

function spawnParticle(cls, styles, keyframes, options){
  const p = document.createElement('div');
  p.className = 'particle ' + cls;
  Object.assign(p.style, styles);
  document.getElementById('stage').appendChild(p);
  const anim = p.animate(keyframes, options);
  anim.onfinish = ()=>p.remove();
  return p;
}
function burstHearts(x,y,count=10){
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2; const dist = 10+Math.random()*24;
    const tx = x + Math.cos(ang)*dist; const ty = y + Math.sin(ang)*dist - 10;
    spawnParticle('heart', {left:x+'px', top:y+'px', color:choice(['#ff4d6d','#ff8fa3','#e03131','#f783ac'])}, [
      {transform:'translate(-50%,-50%) scale(0.8)', opacity:0.0},
      {transform:`translate(${tx-x-50}%, ${ty-y-50}%) scale(1.2)`, opacity:1, offset:.6},
      {transform:`translate(${tx-x-50}%, ${ty-y-70}%) scale(0.9)`, opacity:0}
    ], {duration:600+Math.random()*400, easing:'ease-out', fill:'forwards'}).textContent='â¤';
  }
}
function burstConfetti(x,y,count=14){
  for(let i=0;i<count;i++){
    const col = choice(['#f94144','#f3722c','#f9c74f','#90be6d','#577590','#f72585','#4cc9f0']);
    const rx = (Math.random()-0.5)*60; const ry = (Math.random()-0.5)*40; const rot = (Math.random()*720-360)+'deg';
    spawnParticle('confetti', {left:(x-4)+'px', top:(y-6)+'px', background:col}, [
      {transform:'translate(0,0) rotate(0)', opacity:1},
      {transform:`translate(${rx}px, ${40+ry}px) rotate(${rot})`, opacity:0}
    ], {duration:700+Math.random()*500, easing:'cubic-bezier(.2,.8,.2,1)', fill:'forwards'});
  }
}

function buildMask(text, spaceCols=1){
  const rows = 7; const maskRows = Array(rows).fill("");
  const chars = [...text.toUpperCase()];
  chars.forEach((ch, idx) => {
    const pat = FONT_5x7[ch] || FONT_5x7[' '];
    for(let r=0;r<rows;r++){ maskRows[r] += pat[r]; if(idx !== chars.length-1) maskRows[r] += ".".repeat(spaceCols); }
  });
  return maskRows;
}
function collectLetterPositions(maskRows, sw, sh){
  const rows = maskRows.length; const cols = maskRows.reduce((m,row)=>Math.max(m,row.length),0);
  if(!cols) return {positions:[]};
  const totalWTarget = Math.floor(sw * COVER_RATIO);
  const pitchX = Math.max(12, Math.floor(totalWTarget / cols));
  const pitchY = Math.max(12, pitchX);
  const dotW = Math.max(10, pitchX - CELL_GAP); const dotH = Math.max(10, pitchY - CELL_GAP);
  const totalW = cols * pitchX; const totalH = rows * pitchY;
  const x0 = Math.floor((sw - totalW)/2); const y0 = Math.floor((sh - totalH)/3);
  const positions = [];
  for(let c=0;c<cols;c++) for(let r=0;r<rows;r++){
    const ch = (maskRows[r][c] ?? '.'); if(ch==='1'){
      const jx = randInt(-JITTER_PX, JITTER_PX); const jy = randInt(-JITTER_PX, JITTER_PX);
      let x = clamp(x0 + c*pitchX + jx, 0, sw - dotW); let y = clamp(y0 + r*pitchY + jy, 0, sh - dotH);
      positions.push({x,y,w:dotW,h:dotH});
    }
  }
  return {positions};
}
function collectRandomPositions(sw, sh){
  const n_windows = Math.floor((sw * sh) / (WIN_W * WIN_H) * 1.5);
  const positions = [];
  for(let i=0;i<n_windows;i++){
    const jitter_w = Math.floor(WIN_W * JITTER_RATIO); const jitter_h = Math.floor(WIN_H * JITTER_RATIO);
    const w = WIN_W + randInt(-jitter_w, jitter_w); const h = WIN_H + randInt(-jitter_h, jitter_h);
    const x = randInt(0, Math.max(0, sw - w)); const y = randInt(0, Math.max(0, sh - h));
    positions.push({x,y,w,h});
  }
  return positions.sort(()=>Math.random()-0.5);
}
function fadeOutAndRemove(elems, ms=LEA_FADE_MS){
  return new Promise(resolve=>{
    if(!elems || elems.length===0){ resolve(); return; }
    let done = 0;
    for(const el of elems){
      el.animate([{opacity:1,transform:'scale(1)'},{opacity:0,transform:'scale(0.9)'}], {duration:ms, easing:'ease-in'}).onfinish = ()=>{
        el.remove(); if(++done === elems.length) resolve();
      };
    }
  });
}
async function runLetters(word="LEA"){
  const stage = document.getElementById('stage');
  Array.from(stage.querySelectorAll('.tile[data-tag="phase1"]')).forEach(n=>n.remove());
  const sw = stage.clientWidth, sh = stage.clientHeight;
  const {positions} = collectLetterPositions(buildMask(word,1), sw, sh);
  const total = positions.length;
  const created = [];
  await new Promise(res=>{
    let i = 0; (function spawn(){
      if(i>=total){ res(); return; }
      const p = (i+1)/total; const interval = Math.max(END_MS, Math.floor(START_MS*(1-p)*(1-p) + END_MS*p));
      created.push( makeTile(stage, positions[i], "", "phase1") ); i++; later(spawn, interval);
    })();
  });
  await fadeOutAndRemove(created, LEA_FADE_MS);
}
function runFill(){
  const stage = document.getElementById('stage'); const sw = stage.clientWidth, sh = stage.clientHeight;
  const positions = collectRandomPositions(sw, sh); const total = positions.length; let i = 0;
  (function spawn(){
    if(i>=total) return;
    const p = (i+1)/total; const interval = Math.max(END_MS, Math.floor(START_MS*(1-p)*(1-p) + END_MS*p));
    makeTile(stage, positions[i], choice(TIPS), "phase2"); i++; later(spawn, interval);
  })();
  later(async ()=>{
    const cards = Array.from(stage.querySelectorAll('.tile[data-tag="phase2"]')); if(!cards.length) return;
    const pickN = Math.max(8, Math.floor(cards.length*0.25));
    const chosen = cards.sort(()=>Math.random()-0.5).slice(0, pickN);
    await new Promise(done=>{
      let finished = 0;
      chosen.forEach(el=>{
        el.animate([{transform:'translateY(0) rotate(0)', opacity:1},{transform:`translateY(-40px) rotate(${randInt(-12,12)}deg)`, opacity:0}], {duration:500+Math.random()*300, easing:'ease-in'}).onfinish=()=>{
          el.remove(); if(++finished===chosen.length) done();
        };
      });
    });
    BG_COLORS = choice(PALETTES); TIPS = choice(TIPS_SETS); runFill();
  }, 800);
}

/* ç®€å•æ•ˆæœæ¨¡å¼ */
function modeHeartRain(){
  const st = document.getElementById('stage');
  every(()=>{ const x = randInt(20, st.clientWidth-20);
    const dur = 3000 + Math.random()*2000;
    const p = spawnParticle('heart', {left:x+'px', top:-20+'px', color:choice(['#ff4d6d','#ff8fa3','#f06595','#e03131'])}, [
      {transform:'translate(-50%,-50%) scale(0.8)', opacity:0},
      {transform:`translate(-50%, ${st.clientHeight+40}px) scale(1.1)`, opacity:1}
    ], {duration:dur, easing:'linear', fill:'forwards'}); p.textContent='â¤';
  }, 120);
}
function modeSnow(){
  const st = document.getElementById('stage');
  every(()=>{ const x = randInt(0, st.clientWidth); const size = randInt(6,12); const dur = 6000 + Math.random()*4000;
    spawnParticle('snow', {left:x+'px', top:'-10px', width:size+'px', height:size+'px', opacity:.9}, [
      {transform:`translateY(${st.clientHeight+20}px)`, opacity:.95}, {opacity:0}
    ], {duration:dur, easing:'linear', fill:'forwards'});
  }, 80);
}
function modeBalloons(){
  const st = document.getElementById('stage');
  every(()=>{ const x = randInt(20, st.clientWidth-20); const clr = choice(['#ffadad','#ffd6a5','#fdffb6','#caffbf','#9bf6ff','#a0c4ff','#bdb2ff']); const dur = 6000 + Math.random()*4000;
    spawnParticle('balloon', {left:x+'px', bottom:'-30px', background:clr}, [{transform:'translate(-50%, 0)'},{transform:`translate(-50%, -${st.clientHeight+60}px)`, opacity:.2}], {duration:dur, easing:'cubic-bezier(.25,.8,.2,1)', fill:'forwards'});
  }, 280);
}
function modeConfetti(){
  const st = document.getElementById('stage');
  every(()=>{ const x = randInt(0, st.clientWidth); const dur = 2500 + Math.random()*2000; const rot = (Math.random()*720-360)+'deg';
    spawnParticle('confetti', {left:x+'px', top:'-10px', background:choice(['#f94144','#f3722c','#f9c74f','#90be6d','#577590','#f72585','#4cc9f0'])}, [
      {transform:'translateY(0) rotate(0)', opacity:1},{transform:`translateY(${st.clientHeight+20}px) rotate(${rot})`, opacity:.9}
    ], {duration:dur, easing:'linear', fill:'forwards'});
  }, 40);
}
function modeFireworks(){
  const st = document.getElementById('stage');
  every(()=>{ const cx = randInt(80, st.clientWidth-80); const cy = randInt(80, Math.max(120, st.clientHeight*0.6));
    spawnParticle('particle', {left:cx+'px', top:(st.clientHeight+20)+'px', width:'2px', height:'12px', background:'#fff'}, [
      {transform:`translate(-50%, -${st.clientHeight - cy}px)`, opacity:1},{opacity:0}
    ], {duration:700, easing:'cubic-bezier(.3,.9,.2,1)', fill:'forwards'}); later(()=>burstConfetti(cx, cy, 24), 680);
  }, 900);
}

/* ============ GPU ç²’å­å­—å½¢åœºï¼ˆGPGPUï¼‰ ============ */
const GPUGlyph = (() => {
  const diag = (msg) => { document.getElementById('gpuDiag').textContent = msg || ''; };
  let renderer, scene, camera, compScene, compCam, inst, compMat, renderMat, maskTex, stateTex, readRT, writeRT, loopId;
  let COUNT = 40000, BASE_SIZE = 0.012, DAMPING=0.92, DRIVE=0.28, EDGE_THR=0.5, NOISE=0.004, ENERGY_SCALE=1.7, MASK_W=1024, MASK_H=512;
  const PALETTE = ['#ffd3e0','#bde0fe','#c7f9cc','#e9e5ff','#fff6b3','#ffcfb3'];

  const canvas = document.getElementById('gpuCanvas');

  const maskCanvas = document.createElement('canvas'); maskCanvas.width = MASK_W; maskCanvas.height = MASK_H;
  const mctx = maskCanvas.getContext('2d');
  maskTex = new THREE.CanvasTexture(maskCanvas); maskTex.minFilter = THREE.LinearFilter; maskTex.magFilter = THREE.LinearFilter;

  function drawTextMask(text){
    const W = maskCanvas.width, H = maskCanvas.height;
    mctx.clearRect(0,0,W,H); mctx.fillStyle = '#fff';
    let fontSize = Math.floor(H*0.72);
    mctx.font = `700 ${fontSize}px system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Helvetica,Arial`;
    let metrics = mctx.measureText(text);
    while(metrics.width > W*0.85 && fontSize>12){ fontSize-=4; mctx.font = `700 ${fontSize}px system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Helvetica,Arial`; metrics = mctx.measureText(text); }
    mctx.textAlign='center'; mctx.textBaseline='middle';
    const x=W/2, y=H/2 + (metrics.actualBoundingBoxDescent - metrics.actualBoundingBoxAscent)/2;
    mctx.fillText(text, x, y); maskTex.needsUpdate = true;
  }

  function makeRT(side){ return new THREE.WebGLRenderTarget(side, side, {type:THREE.FloatType, format:THREE.RGBAFormat, minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, depthBuffer:false, stencilBuffer:false}); }

  function seedState(texSide){
    const arr = new Float32Array(texSide*texSide*4);
    for(let i=0;i<COUNT;i++){
      const k=i*4;
      arr[k]   = (Math.random()*2-1) * (innerWidth/innerHeight) * 0.95;
      arr[k+1] = (Math.random()*2-1) * 0.95;
      arr[k+2] = (Math.random()*2-1) * 0.02;
      arr[k+3] = (Math.random()*2-1) * 0.02;
    }
    const tex = new THREE.DataTexture(arr, texSide, texSide, THREE.RGBAFormat, THREE.FloatType); tex.needsUpdate = true; return tex;
  }

  function initOnce(){
    renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    const gl = renderer.getContext();
    if(!renderer.capabilities.isWebGL2){ diag('âŒ éœ€è¦ WebGL2'); return false; }
    if(!gl.getExtension('EXT_color_buffer_float')){ diag('âŒ ç¼ºå°‘ EXT_color_buffer_float'); return false; }

    diag('âœ… WebGL2 / Float RT OK');

    scene = new THREE.Scene();
    camera = new THREE.OrthographicCamera(-1,1,1,-1, -10, 10);

    compScene = new THREE.Scene(); compCam = new THREE.OrthographicCamera(-1,1,1,-1,-1,1);

    const texSide = Math.ceil(Math.sqrt(COUNT));
    readRT = makeRT(texSide); writeRT = makeRT(texSide);
    stateTex = seedState(texSide);

    // è®¡ç®— passï¼ˆä¸ç”¨æ‰‹å†™ #versionï¼›Three ä¼šè‡ªåŠ¨åŠ ï¼‰
    const quadGeom = new THREE.PlaneGeometry(2,2);
    compMat = new THREE.ShaderMaterial({
      glslVersion: THREE.GLSL3,
      uniforms: {
        prevTex:   { value: stateTex },
        maskTex:   { value: maskTex },
        uTexSize:  { value: new THREE.Vector2(texSide, texSide) },
        uMaskSize: { value: new THREE.Vector2(MASK_W, MASK_H) },
        uAspect:   { value: innerWidth/innerHeight },
        uDt:       { value: 0.016 },
        uTime:     { value: 0 },
        uDrive:    { value: DRIVE },
        uDamping:  { value: DAMPING },
        uNoise:    { value: NOISE },
        uEdgeThr:  { value: EDGE_THR },
        uEnergy:   { value: 0.0 }
      },
      vertexShader: `
        out vec2 vUv;
        void main(){ vUv = position.xy*0.5+0.5; gl_Position = vec4(position,1.0); }
      `,
      fragmentShader: `
        precision highp float; precision highp sampler2D;
        in vec2 vUv; out vec4 outColor;
        uniform sampler2D prevTex;   // (x,y,vx,vy)
        uniform sampler2D maskTex;   // æ–‡æœ¬ alpha
        uniform vec2 uTexSize, uMaskSize; 
        uniform float uAspect, uDt, uTime, uDrive, uDamping, uNoise, uEdgeThr, uEnergy;

        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
        float rand(vec2 p){ return hash(p + uTime*0.123); }

        vec2 worldToMask(vec2 pos){
          float u = (pos.x / uAspect + 1.0) * 0.5;
          float v = 1.0 - (pos.y + 1.0) * 0.5;
          return vec2(u, v);
        }

        vec3 sampleAlphaGrad(vec2 pos){
          vec2 uv = worldToMask(pos); vec2 dp = 1.0 / uMaskSize;
          float a  = texture(maskTex, uv).a;
          float ax = texture(maskTex, uv + vec2(dp.x,0.0)).a - texture(maskTex, uv - vec2(dp.x,0.0)).a;
          float ay = texture(maskTex, uv + vec2(0.0,dp.y)).a - texture(maskTex, uv - vec2(0.0,dp.y)).a;
          return vec3(a, ax*0.5, ay*0.5);
        }

        void main(){
          vec4 s = texture(prevTex, vUv);
          vec2 pos = s.xy; vec2 vel = s.zw;

          vec3 ag = sampleAlphaGrad(pos);
          float a = ag.x; vec2 grad = vec2(ag.y, ag.z);
          float sgn = (a < uEdgeThr) ? 1.0 : -0.5;
          vec2 F = sgn * grad * uDrive * (0.5 + uEnergy);

          vec2 N = (vec2(rand(vUv+0.37), rand(vUv+0.79))*2.0-1.0) * uNoise * (0.6 + uEnergy);

          vel = (vel + F) * uDamping + N;
          pos += vel * uDt;

          float X = uAspect * 0.98;
          if(pos.x < -X){ pos.x=-X; vel.x*=-0.4; }
          if(pos.x >  X){ pos.x= X; vel.x*=-0.4; }
          if(pos.y < -0.98){ pos.y=-0.98; vel.y*=-0.4; }
          if(pos.y >  0.98){ pos.y= 0.98; vel.y*=-0.4; }

          outColor = vec4(pos, vel);
        }
      `
    });
    compScene.add(new THREE.Mesh(quadGeom, compMat));

    // æ¸²æŸ“ passï¼ˆInstancedMeshï¼‰
    const quad = new THREE.PlaneGeometry(1,1);
    renderMat = new THREE.ShaderMaterial({
      glslVersion: THREE.GLSL3,
      uniforms: {
        posTex:   { value: readRT.texture },
        uTexSize: { value: new THREE.Vector2(texSide, texSide) },
        uAspect:  { value: innerWidth/innerHeight },
        uSize:    { value: BASE_SIZE },
        uEnergy:  { value: 0.0 },
        uP0: { value: new THREE.Color(PALETTE[0]) },
        uP1: { value: new THREE.Color(PALETTE[1]) },
        uP2: { value: new THREE.Color(PALETTE[2]) },
        uP3: { value: new THREE.Color(PALETTE[3]) },
        uP4: { value: new THREE.Color(PALETTE[4]) },
        uP5: { value: new THREE.Color(PALETTE[5]) }
      },
      vertexShader: `
        precision highp float; precision highp sampler2D;
        uniform sampler2D posTex; uniform vec2 uTexSize; uniform float uAspect; uniform float uSize; uniform float uEnergy;
        out float vIndex; out vec2 vCenter;
        void main(){
          int tw = int(uTexSize.x);
          int i = gl_InstanceID;
          int x = i % tw; int y = i / tw;
          vec2 uv = (vec2(float(x), float(y)) + 0.5) / uTexSize;
          vec4 s = texture(posTex, uv);
          vec2 pos = s.xy;
          float size = uSize * (1.0 + uEnergy*0.6);
          vec2 p = pos + position.xy * size;

          vIndex = float(i % 6);
          vCenter = position.xy;

          gl_Position = vec4(p.x / uAspect, p.y, 0.0, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform vec3 uP0,uP1,uP2,uP3,uP4,uP5;
        in float vIndex; in vec2 vCenter; out vec4 outColor;
        vec3 pick(float i){
          int idx = int(i + 0.5);
          if(idx==0) return uP0; if(idx==1) return uP1; if(idx==2) return uP2;
          if(idx==3) return uP3; if(idx==4) return uP4; return uP5;
        }
        void main(){
          float d = distance(vCenter, vec2(0.0));
          float alpha = smoothstep(0.62, 0.45, d);  // åœ†ç‚¹è½¯è¾¹
          vec3 col = pick(vIndex);
          outColor = vec4(col, alpha);
        }
      `,
      transparent: true
    });
    inst = new THREE.InstancedMesh(quad, renderMat, COUNT);
    inst.frustumCulled = false; scene.add(inst);

    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      renderMat.uniforms.uAspect.value = innerWidth/innerHeight;
      compMat.uniforms.uAspect.value = innerWidth/innerHeight;
    });

    return true;
  }

  function computeStep(dt, energy){
    compMat.uniforms.uDt.value = dt;
    compMat.uniforms.uTime.value += dt;
    compMat.uniforms.uEnergy.value = energy;
    compMat.uniforms.prevTex.value = stateTex ? stateTex : readRT.texture;

    renderer.setRenderTarget(writeRT);
    renderer.render(compScene, compCam);
    renderer.setRenderTarget(null);

    stateTex = null;
    const tmp = readRT; readRT = writeRT; writeRT = tmp;
  }

  function loop(){
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.04, (now-last)/1000); last=now;
      const energy = 0.0; // ï¼ˆå¯æ¥å…¥éŸ³é¢‘èƒ½é‡ï¼‰
      computeStep(dt, energy);
      renderMat.uniforms.posTex.value = readRT.texture;
      renderMat.uniforms.uEnergy.value = energy;
      renderer.render(scene, camera);
      loopId = requestAnimationFrame(tick);
    }
    loopId = requestAnimationFrame(tick);
  }

  return {
    start(opts){
      if(!initOnce()) return;
      drawTextMask((opts?.text || 'LEA').toUpperCase());
      loop();
    },
    stop(){ if(loopId) cancelAnimationFrame(loopId); loopId = null; },
    setText(t){ drawTextMask((t||'LEA').toUpperCase()); },
    resetParticles(){ /* å¯æ‰©å±•: é‡æ–°æ’­æ’’ç§å­ */ }
  };
})();

window.GPUGlyph = GPUGlyph;

/* ============ æ¨¡å¼åˆ‡æ¢ ============ */
let CURRENT_MODE = 'LEA';
const gpuRoot = document.getElementById('gpuRoot');
const btnGPUText = document.getElementById('btnGPUText');
function showGPU(show){
  gpuRoot.style.display = show ? 'block' : 'none';
  document.getElementById('stage').style.visibility = show ? 'hidden' : 'visible';
  btnGPUText.style.display = show ? 'inline-block' : 'none';
}
function closeAll(){ clearAllTimers(); document.getElementById('stage').innerHTML = ''; }
async function startLEAFlow(){
  closeAll(); showGPU(false);
  BG_COLORS = PALETTES[0]; TIPS = TIPS_SETS[0];
  await runLetters(WORD); runFill();
}
function setMode(m){
  CURRENT_MODE = m;
  document.getElementById('btnMode').textContent = 'æ¨¡å¼ï¼š' + ({'LEA':'LEA','HEART_RAIN':'å¿ƒå½¢é›¨','FIREWORKS':'çƒŸèŠ±','SNOW':'é›ªèŠ±','BALLOONS':'æ°”çƒä¸Šæµ®','CONFETTI':'Confetti','GPU':'GPU å­—å½¢ç²’å­'}[m]||m);
  GPUGlyph.stop?.(); closeAll();
  if(m==='LEA'){ startLEAFlow(); return; }
  if(m==='HEART_RAIN'){ showGPU(false); modeHeartRain(); return; }
  if(m==='FIREWORKS'){ showGPU(false); modeFireworks(); return; }
  if(m==='SNOW'){ showGPU(false); modeSnow(); return; }
  if(m==='BALLOONS'){ showGPU(false); modeBalloons(); return; }
  if(m==='CONFETTI'){ showGPU(false); modeConfetti(); return; }
  if(m==='GPU'){ showGPU(true); GPUGlyph.start({ text: WORD }); return; }
}

/* ============ é¡¶éƒ¨äº¤äº’/éŸ³ä¹ ============ */
const btnMode = document.getElementById('btnMode');
const menuMode = document.getElementById('menuMode');
btnMode.addEventListener('click', ()=>{ menuMode.classList.toggle('open'); btnMode.setAttribute('aria-expanded', menuMode.classList.contains('open')?'true':'false'); });
menuMode.addEventListener('click', (e)=>{ const m=e.target.getAttribute('data-mode'); if(!m) return; menuMode.classList.remove('open'); btnMode.setAttribute('aria-expanded','false'); setMode(m); });
document.addEventListener('click', (e)=>{ if(!menuMode.contains(e.target) && e.target!==btnMode){ menuMode.classList.remove('open'); btnMode.setAttribute('aria-expanded','false'); }});

document.getElementById('btnClear').addEventListener('click', ()=>{ if(CURRENT_MODE==='GPU'){ GPUGlyph.resetParticles?.(); } else { closeAll(); } });

btnGPUText.addEventListener('click', ()=>{
  const t = prompt('è¾“å…¥è¦æ˜¾ç¤ºçš„å­—å½¢ï¼ˆ1~24å­—ç¬¦ï¼‰ï¼š', WORD) || WORD;
  btnGPUText.textContent = 'å­—ï¼š' + t.toUpperCase();
  GPUGlyph.setText?.(t);
});

/* éŸ³ä¹ */
const bgm = document.getElementById('bgm');
const btnMusic = document.getElementById('btnMusic');
const menuMusic = document.getElementById('menuMusic');
const volSlider = document.getElementById('musicVol');
const btnMute = document.getElementById('btnMute');
const unlockMask = document.getElementById('unlockMask');

try { const lastVol = localStorage.getItem('bgm.volume'); bgm.volume = lastVol!==null ? Math.min(1, Math.max(0, parseFloat(lastVol))) : 0.6; volSlider.value = String(bgm.volume); } catch(_){ bgm.volume = 0.6; }

async function autoStartBgm(){
  try{ bgm.muted=false; await bgm.play(); btnMusic.textContent='éŸ³ä¹ï¼šæš‚åœ'; unlockMask.classList.remove('show'); }
  catch(e){ unlockMask.classList.add('show'); const once = async ()=>{ unlockMask.classList.remove('show'); document.removeEventListener('pointerdown', once, {capture:true}); try{ await bgm.play(); btnMusic.textContent='éŸ³ä¹ï¼šæš‚åœ'; }catch(_){}}; document.addEventListener('pointerdown', once, {once:true, capture:true}); }
}
async function togglePlay(){ try{ if(bgm.paused){ await bgm.play(); btnMusic.textContent='éŸ³ä¹ï¼šæš‚åœ'; } else { bgm.pause(); btnMusic.textContent='éŸ³ä¹ï¼šæ’­æ”¾'; } } catch(e){ alert('æ’­æ”¾å¤±è´¥ï¼šè¯·ç¡®è®¤ lea.mp3 å·²ä¸Šä¼ ä¸”è·¯å¾„æ­£ç¡®ã€‚'); console.error(e); } }
let pressTimer=null, pressed=false;
btnMusic.addEventListener('pointerdown', ()=>{ pressed=true; pressTimer=setTimeout(()=>{ if(pressed) menuMusic.classList.toggle('open'); }, 400); });
btnMusic.addEventListener('pointerup', async ()=>{ if(pressTimer) clearTimeout(pressTimer); if(pressed && !menuMusic.classList.contains('open')) await togglePlay(); pressed=false; });
document.addEventListener('click', (e)=>{ if(!menuMusic.contains(e.target) && e.target!==btnMusic) menuMusic.classList.remove('open'); });
volSlider.addEventListener('input', (e)=>{ const v=parseFloat(e.target.value); bgm.volume=isNaN(v)?0.6:v; try{ localStorage.setItem('bgm.volume', String(bgm.volume)); }catch(_){} });
btnMute.addEventListener('click', ()=>{ bgm.muted=!bgm.muted; btnMute.textContent = bgm.muted ? 'å–æ¶ˆé™éŸ³' : 'é™éŸ³'; });

/* å¯åŠ¨é»˜è®¤æ¨¡å¼ */
window.addEventListener('load', ()=>{ setMode('LEA'); btnMusic.textContent = bgm.paused ? 'éŸ³ä¹ï¼šæ’­æ”¾' : 'éŸ³ä¹ï¼šæš‚åœ'; autoStartBgm(); });

})(); // IIFE ç»“æŸ
</script>
</body>
</html>
